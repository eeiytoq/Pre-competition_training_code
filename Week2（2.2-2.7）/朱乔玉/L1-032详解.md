## 1. 算法步骤详解

算法的核心在于对比 **目标长度 $N$** 与 **原字符串实际长度 $L$**。
### 1.1 输入

首先读取 $N$ 和填充字符 $C$。通过 `getline` 获取完整的原始字符串 $S$（长度为 $L$）。
### 1.2 分支判断

根据 $L$ 和 $N$ 的关系，程序进入两个逻辑分支：

- **分支 A：$L < N$ (需要填充)**
    
    计算需要补齐的差值 $D = N - L$。先循环打印 $D$ 个字符 $C$，再原样打印字符串 $S$。
 
- **分支 B：$L \ge N$ (需要截断)**
    
    由于只保留后 $N$ 位，利用 `s.substr(L - N)` 截取从倒数第 $N$ 个字符开始到结尾的所有内容。

## 2. 为什么不能用 `cin >> s`？

在处理这道题时，如果不使用 `getline(cin, s)` 而错误地使用 `cin >> s`，会遇到以下问题：
### 2.1 空格截断问题

`cin >> s` 在读取字符串时，会以**空白字符**（空格、制表符、换行符）作为结束标志。

- **输入样例 1**：`I love GPLT`
- **使用 `cin >> s`**：它只会读入 `I`，剩下的 `love GPLT` 会留在缓冲区。
- **后果**：程序计算出的长度 $L$ 仅为 1，导致输出结果完全错误。

### 2.2 换行符残留问题

除了使用`getline(cin, s)`之外，还需要在代码中加入 `getchar()` 

- 当你执行 `cin >> n >> ch;` 后，输入流缓冲区中其实还剩下一个**换行符 `\n`**。
- 如果你直接调用 `getline`，它会读到这个 `\n` 并认为输入已经结束，导致读入的字符串为空。
- **坑点**：如果你不用 `getchar()` 或 `cin.ignore()`，即使用了 `getline` 也会导致答案错误。
- 除了这一题之外，还有`L1-039`也有一样的问题，需要使用`getchar()` 或 `cin.ignore()`来吸收掉前一行输入残留下的换行符，否则的话就会出现答案错误。